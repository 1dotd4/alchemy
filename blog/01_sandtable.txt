Alchemy is an extensible computer algebra library. It aims to provide a
meaningful way to express and use mathematical objects. A notable goal is
breaking cryptography without fighting the library.

# Writing on sandtable

Alchemy tries to be:
- readable -- written for readability and well documented;
- portable -- written in R7RS (hackable, scriptable, ...) and tested on
  chicken-scheme and gambit;
- first-class higher order functions for algebric algorithms;
- TDD -- current needs instead of fuzzy future needs.

Due to Scheme nature, you have an incredible tool. You can do virtually
anything. But you need a proper setup.

## Staring at patterns

It all started with the realization that staring at something enough will make
you brain work and recognize patterns. Thus, we stare at patterns.

When staring at patterns you are looking for invariants. I think patterns are
invariants.  That's what pretty. When you find a pattern you can't unsee it and
you just discovered a new layer where the pattern lives.

Invariants are things that are equal, similar or some other property that makes
two things the "same" even if they have different form or shape. An easy
computational example is the Greatest Common Divisor on (Euclidean) rings. You
just need one implementation of the GCD for all rings. Moreover, you can reject
OOP and its insane way of redefining stuff for each type.

You may look at Haskell for inspiration and say how nice it is: free type
checking! But the syntax and other annoying parts would stop us from modeling
our lava into nice placed stones. So the first step is borrowing one of the nice
part of Haskell: propositions as types. We encapsulate the proof of a type
inside a variable.  This is what Haskell does implicitly.

Take for example the greatest commond divosor algorithm.

  -- out type
  class Ring a where
    (<+>) :: a -> a -> a
    (<*>) :: a -> a -> a
    neg   :: a -> a
    one :: a
    zero  :: a

  -- our proof instance
  instance Ring Z where
    (<+>) = (+)
    (<*>) = (*)
    neg   = negate
    zero  = 0
    one   = 1

  -- our implementation of the algorithm
  gcd :: (Ring t) => t * t -> t
  gcd = ...

  -- virtually passed ``gcd :: RingProf -> t * t -> t``
  gcd 3 7

So in Scheme it becomes a bit verbose due to its nature, but this can be slimmed
with some macros later.

  (gcd my-ring-proof 3 7)

The proof will contain all the refernces to the algorithm needed to implement
the GCD.

This same method will allow us to implement the power function for both integers
over a modulo and points over an elliptic curve.

Doing proof manipulation is going to be the most important step. In this way a
proof of a ring already contains the proof of a group (on the sum operation). It
can be reimplemented or induced using coercion.  After this we will have nice
and generic higher-order functions that will work with any object respecting
some abstract pattern. Infact, the same GCD function can be used for
polynomials.

## APL function application style

To implement the first algorithms applied to some context and it comes to mind
that APL has a nice and elegant function application style. For example, A+.Ã—B
computes the inner product without asking you to scan rows and columns of a
matrix.
